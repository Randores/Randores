/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 socraticphoenix@gmail.com
 * Copyright (c) 2016 contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package com.gmail.socraticphoenix.forge.randore;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.GameType;
import net.minecraftforge.event.entity.living.LivingHurtEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;

import java.util.HashMap;
import java.util.Map;

public class RandoresInvulnerabilityListener {
    private static final Map<EntityPlayer, Info> playerMap = new HashMap<EntityPlayer, Info>();

    public static void set(EntityPlayerMP player) {
        synchronized (playerMap) {
            if(!playerMap.containsKey(player)) {
                playerMap.put(player, new Info(player.interactionManager.getGameType(), player.getPositionVector()));
            }
        }
    }

    public static void remove(EntityPlayer player) {
        synchronized (playerMap) {
            if(playerMap.containsKey(player)) {
                player.setGameType(playerMap.get(player).getType());
                playerMap.remove(player);
            }
        }
    }

    @SubscribeEvent
    public void onTick(TickEvent.ServerTickEvent ev) {
        synchronized (playerMap) {
            for (Map.Entry<EntityPlayer, Info> entry : playerMap.entrySet()) {
                EntityPlayer player = entry.getKey();
                Info info = entry.getValue();
                Vec3d loc = info.getLoc();
                player.setPosition(loc.xCoord, loc.yCoord, loc.zCoord);
                player.setGameType(GameType.SPECTATOR);
            }
        }
    }

    @SubscribeEvent
    public void onDamage(LivingHurtEvent ev) {
        synchronized (playerMap) {
            if (ev.getEntity() instanceof EntityPlayer && playerMap.containsKey(ev.getEntity().getUniqueID())) {
                ev.setCanceled(true);
            }
        }
    }

    private static class Info {
        private GameType type;
        private Vec3d loc;

        public Info(GameType type, Vec3d loc) {
            this.type = type;
            this.loc = loc;
        }

        public GameType getType() {
            return this.type;
        }

        public Vec3d getLoc() {
            return this.loc;
        }

    }

}
